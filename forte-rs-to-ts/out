Project Path: forte-rs-to-ts

Source Tree:

```txt
forte-rs-to-ts
├── CLAUDE.md
├── Cargo.lock
├── GOAL.md
├── PLAN.md
├── out
├── rust-toolchain.toml
└── src
    └── main.rs

```

`CLAUDE.md`:

```md
Don't type comments.
Project goal is in `GOAL.md`

```

`Cargo.lock`:

```lock
# This file is automatically @generated by Cargo.
# It is not intended for manual editing.
version = 4

[[package]]
name = "forte-rs-to-ts"
version = "0.1.0"

```

`GOAL.md`:

```md
User pass rust project path to this program.

This program analyzes Rust code that,

1. Finds `src/pages/**/mod.rs`
2. Filters only those with `pub fn handler`
3. That mod must have `Props` type defined
4. Extracts the `Props` type definition recursively
5. Converts Rust type definitions to TypeScript equivalents
6. Outputs the TypeScript definitions to stdout or a file

```

`PLAN.md`:

```md
### Module Traversal & Discovery

- **Access HIR**: In the `after_analysis` callback, retrieve the High-Level Intermediate Representation (HIR) via `tcx.hir().krate()`.
- **Iterate Items**: Loop through all `Item`s in the local crate using `tcx.hir().items()`.
- **Filter Modules**: Check if `item.kind` is `ItemKind::Mod`.
- **Resolve File Paths**:
  - Get the span of the module using `item.span`.
  - Convert span to a file path using `tcx.sess.source_map().span_to_filename(span)`.
- **Match Path Pattern**: Apply a string check or Regex to ensure the path ends in `mod.rs` and contains `src/pages`.

### Item Validation (Handler & Props)

- **Inspect Module Children**: For every matching module, retrieve its children using `tcx.module_children(item.owner_id.def_id)`.
- **Locate Handler**:
  - Search for a child item named `"handler"`.
  - Verify `child.vis` is `Public`.
  - Verify `child.res` points to a `DefKind::Fn`.
- **Locate Props**:
  - Search for a child item named `"Props"`.
  - Verify it is a type definition (`DefKind::Struct`, `DefKind::Enum`, or `DefKind::TyAlias`).
  - Capture the `DefId` of the `Props` item.

### Recursive Type Extraction

- **Initialize Context**: Create a `TypeConverter` struct holding `TyCtxt` and a `HashSet<DefId>` to track visited types (preventing infinite recursion on cyclic types).
- **Resolve Root Type**: Use `tcx.type_of(props_def_id).instantiate_identity()` to get the specific `Ty<'tcx>` for the `Props` struct.
- **Pattern Match Types**: implement a `convert_type` function that matches on `ty.kind()`:
  - **Primitives**: Map `Bool` → `boolean`, `Int/Uint/Float` → `number`, `Str` → `string`.
  - **Slices/Arrays**: Map `Slice(inner)` or `Array(inner)` → `Array<convert_type(inner)>`.
  - **Tuples**: Map `Tuple(fields)` → TypeScript Tuple `[T1, T2]`.
  - **Refs**: Peel off references (`&T`) using `ty.peel_refs()` and analyze the inner type.
- **Handle ADTs (Structs/Enums)**:
  - **Identify Standard Lib**: Check if the crate name of the DefId is `std`, `core`, or `alloc`.
    - Map `Option<T>` → `T | null`.
    - Map `Vec<T>` → `Array<T>`.
    - Map `HashMap<K, V>` → `Record<K, V>` (if K is string-like) or `Map<K, V>`.
    - Map `String` → `string`.
  - **User Structs**:
    - Iterate over `adt_def.all_fields()`.
    - Extract field name and type.
    - Recursively call `convert_type` on field types.
  - **User Enums**:
    - Iterate over `adt_def.variants()`.
    - Handle **Unit Variants** as string literals (Union type).
    - Handle **Struct Variants** (if tagged) based on `#[serde(tag = "...")]` attributes if needed, or default Rust JSON serialization shape.

### TypeScript Generation

- **Define AST**: Create a simple Rust enum structure to represent TypeScript nodes: `TsInterface`, `TsTypeAlias`, `TsField`, `TsUnion`.
- **Accumulate Definitions**: As the recursive extractor runs, collect named structs/enums into a `Vec<TsDefinition>` to separate nested types from the main `Props`.
- **Formatter**: Implement a `fmt::Display` or helper to write the AST to valid TypeScript syntax.
  - Convert `RustSnakeCase` field names to `camelCase` if necessary (or keep as is).
  - Ensure proper indentation.
  - Prefix the root `Props` with `export`.

### Output Handling

- **Collect Results**: Map each valid page path to its generated TypeScript string.
- **Write Output**:
  - If stdout: Print a JSON structure or delimited text block containing filename + code.
  - If file: Create the target file (e.g., `generated_types.ts`) and write the interfaces, handling name collisions (e.g., `PageA_Props`, `PageB_Props`) if aggregating multiple pages into one file.

```

`rust-toolchain.toml`:

```toml

[toolchain]
channel = "nightly"
components = ["rustc-dev", "llvm-tools-preview", "rust-src"]

```

`src/main.rs`:

```rs
#![feature(rustc_private)]

extern crate rustc_driver;
extern crate rustc_hir;
extern crate rustc_interface;
extern crate rustc_middle;
extern crate rustc_session;
extern crate rustc_span;

use rustc_driver::{Callbacks, Compilation, run_compiler};
use rustc_interface::interface::Compiler;
use rustc_middle::ty::TyCtxt;
use std::env;
use std::process::Command;

struct Analyzer;

impl Callbacks for Analyzer {
    fn after_analysis<'tcx>(&mut self, _compiler: &Compiler, _tcx: TyCtxt<'tcx>) -> Compilation {
        Compilation::Stop
    }
}
fn main() {
    if env::var("MY_ANALYZER_WRAPPER_MODE").is_ok() {
        let mut args: Vec<String> = env::args().collect();

        let is_build_script = args.iter().any(|arg| arg == "build_script_build");

        if is_build_script {
            let rustc_path = &args[1];
            let rustc_args = &args[2..];

            let status = Command::new(rustc_path)
                .args(rustc_args)
                .status()
                .expect("Failed to execute original rustc");

            std::process::exit(status.code().unwrap_or(1));
        }

        if args.len() > 1 {
            args.remove(1);
        }
        let mut callbacks = Analyzer;
        run_compiler(&args, &mut callbacks);
        return;
    }
    let target_dir = env::args()
        .nth(1)
        .unwrap_or_else(|| "../forte-manual/rs".to_string());
    let current_exe = env::current_exe().expect("Failed to find current exe");
    println!("Running cargo check on: {target_dir}");

    let status = Command::new("cargo")
        .arg("check")
        .current_dir(target_dir)
        .env("RUSTC_WORKSPACE_WRAPPER", current_exe)
        .env("MY_ANALYZER_WRAPPER_MODE", "true")
        .status()
        .expect("Failed to run cargo");

    if !status.success() {
        std::process::exit(status.code().unwrap_or(1));
    }
}

```